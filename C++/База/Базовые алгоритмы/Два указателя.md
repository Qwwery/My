[[Базовые алгоритмы||Базовый алгоритм]] в спорт проге
Метод двух указателей - важный метод, который часто используется в спорт-проге.

Метод используется для отслеживания элементов в массиве, позиций или поддержания некоторого условия в задаче

Сам метод лучше обозначить метод k указателей или метод конечного количества указателей

Мы будем использовать чаще как указатель на элемент в массиве.

## Задача на слияние 
Дано два массива, которые отсортированы по возрастанию
Надо поместить два массива в один отсортированный 
Наивное решение: Дублируем все элементы из массивов в новый, и сортируем новый массив. O(n * log2(n))
![[Pasted image 20250403134820.png]]
Мы можем воспользоваться важным фактом того, что элементы уже отсортированные 

Решаем задачу поэтапно
1) Определяем, какой элемент должен быть в позиции C[0]
2) Кто должен лежать в позиции C[1]
3) Повторяем до конца
Этот алгоритм линейный O(n)

Реализация:
Будем использовать 3 указателя u1, u2, u3, которые будут указывать на начальные индексы массивов A, B, C соответственно.
![[Pasted image 20250403135306.png]]
```
int main() {
	vector<int> A(5), B(5), C(10); // Массивы осортированны
	...
	int u1 = 0, u2 = 0, u3 = 0;
	while (u1 < A.size() && u2 < B.size()) {
		if (u1 < A.size() && u2 < B.size()) {
			if (A[u1] < B[u2]) {
				C[u3] = A[u1];
				u1++;
				u3++;
			}
			else {
				C[u3] = B[u2];
				u2++;
				u3++;
			}
		}
	}
	while (u1 < A.size()) {
		C[u3] = A[u1];
		u1++;
		u3++;
	}
	while (u2 < B.size()) {
		C[u3] = A[u2];
		u2++;
		u3++;
	}
}
```

## Поддержка отрезка
Рассмотрим задачу о поддержании длины "хорошего" отрезка в массиве
Необходимо найти максимальный отрезок массива, в котором нет нулей.
Данную задачу можно решить, например, использовав for for for, т.е. кубическую асимптотику.

В каждой задаче под значение "хороший" может быть различное условие.

Пусть есть дополнительные ограничения:
1) Если отрезок хороший, то все его подотрезки хорошие
2) Если отрезок плохой, то все его подотрезки либо плохие, либо хорошие.
ЭТИ ПРАВИЛА МОЖНО НАРУШИТЬ В ОЧЕНЬ РЕДКИХ СЛУЧАЯХ 
Если эти условия не выполняются, то придется использовать for for for
![[Pasted image 20250403140719.png]]
1)  Берем "Хороший" отрезок
2) Увеличиваем его правую границу (r) на 1
3) Если новый отрезок хороший, то мы увеличили наш отрезок без проблем
	Иначе, когда правая граница сдвинулась, у нас всё сломалось и нам необходимо подводить отрезок до хорошего, для этого сдвигаем левую позицию. До тех пор, пока левая и правая граница не образуют "Хороший" отрезок.
![[Pasted image 20250403140912.png]]№№
## Дополнительное применение
1) Движение двух указателей в оном направлении на массиве с фиксированным шагом (движение рамки на массиве)
2) Движение двух указателей друг к другу с концов массива
3) Подсчет величин на хороших отрезках 
4) Нахождение отрезка с наименьшим разбросом элементов
5) Подсчет хороших отрезков

## Задача 
Вы — университетский тренер. Всего в университете под Вашим надзором nn студентов, умение программировать ii-го студента равно aiai.

Вы хотите составить команду для нового соревнования по программированию. Как Вы знаете, чем больше студентов на соревновании — тем больше шансов победить! Поэтому Вы хотите составить максимальную по количеству студентов команду. Но Вы также знаете, что команда должна быть сбалансированной. Это означает, что умение программировать каждой пары студентов в команде должно отличаться не более, чем на 55.

Ваша задача — найти максимально возможное количество студентов в сбалансированной команде.

Входные данные

Первая строка входных данных содержит одно целое число nn (1≤n≤2⋅1051≤n≤2⋅105) — количество студентов.

Вторая строка входных данных содержит nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109), где aiai означает умение ii-го студента программировать.

Выходные данные

Выведите одно целое число — максимально возможное количество студентов в сбалансированной команде.

2 Варианта решения
1) школьный
2) студенческий
Школьный вариант:
```
int main() {
	int n;
	cin >> n;
	vector<int> A(n);
	for (int i = 0; i < n; i++)
		cin >> A[i];
	sort(A.begin(), A.end());

	int l = 0;
	int r = 0;
		int res = 1;
	while (r < A.size()) {
		if (A[r] - A[l] <= 5) {
			res = max(res, r - l + 1);
			r++;
		}
		else {
			l++;
		}
	}
	cout << res;
}
```
