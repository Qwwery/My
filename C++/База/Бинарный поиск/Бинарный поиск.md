[[Базовые алгоритмы||Базовый алгоритм]] в спорт-проге
Дан массив целых чисел A длинны n.
a1, a2, a3, ..., an
Задано q запросов, каждый запрос - это проверка, существует ли число bj в массиве A

Наивное решение - линейный поиск
```
int main() {
	int n;
	cin >> n;
	vector<int> A(n);
	for (int i = 0; i < n; i++)
		cin >> A[i];

	int q, b;
	cin >> q;
	bool flag;
	for (int j = 0; j < q; j++) {
		flag = false;
		cin >> b;
		for (int i = 0; i < A.size(); i++)
			if (A[i] == b)
				flag = true;
		if (flag)
			cout << "Yes";
		else
			cout << "No";
	}
}
```
Оптимизация
1) Отсортируем массив
2) Нам нужны 3  [[Два указателя||указателя]]: left, right, midl
![[Pasted image 20250404220213.png]]
![[Pasted image 20250404220600.png]]
Принцип
1) Разделим нашу область поиска на две равные части, для этого mid определяем, по формуле mid = (left + right) / 2
2) Элемент, который мы ищем лежит в одной из частей (красной \ синей)

Сравниваем элемент центральный и тот, который мы ищем. центральный меньше - элемент правее, иначе элемент левее

Последовательность действий алгоритма:
1) Находим середину области поиска
2) Делаем сравнение элемента с индексом mid со значением поиска b
3) В зависимости от результата сдвигаем либо left в середину, либо right
4) Продолжаем выполнять движение до тех пор, пока границы не станут соседними right - left > 1
5) Делаем дополнительную проверку элементов после окончания цикла while

```
int main() {
	int n;
	cin >> n;
	vector<int> A(n);
	for (int i = 0; i < n; i++)
		cin >> A[i];

	int q, b;
	cin >> q;
	for (int j = 0; j < q; j++) {
		cin >> b;
		int l = 0, r = n - 1, m = 0;
		while (r - l > 1) {
			m = (r + l) / 2;
			if (A[m] < b)
				l = m;
			else
				r = m;
		}
		if (A[l] == b || A[r] = b)
			cout << "Yes";
		else
			cout << "No";
	}
		
}
```
Бинарный поиск на массиве можно реализовать по-разному.
Чуть ранее мы реализовывали версию бинарного поиска, в которой искали ответ в области включительно до полуинтервалов [left, right].
Мы можем изменить область поиска элемента до полуинтервалов [left, right)
Это позволит меньше делать действий в дополнительной проверке элементов после цикла while, но усложняет выбор сдвига границ.

Рассмотрим небольшое усложнение задачи про поиск элементов в массиве

Пусть нас интересует не только существование элемента в массиве, но и определить какое их количество.

При помощи бинарного поиска мы можем определить первую и последнюю позицию в отсортированном массиве, где встречается элемент.

