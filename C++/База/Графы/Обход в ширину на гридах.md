[[Обход в ширину]] на гидрах - алгоритм для работы с полем(как на девелобеар 2025)
Грид-граф, рисунок которого встроенный в евклидово пространство, образует правильную мозаику

Один из распространенных типов графа - квадратный сетчатый граф.

Яркий пример задач на граф в виде гридов- это шахматы 
## Задача
Есть конь на шахматной доске размером n * n. Находится в x, y. Какое минимальное количество ходов должен сделать конь, чтобы дойти до края доски 

Вариант не очень:
Переводим всю матрицу в список смежностей 
и идем в лоб

Модификация
Идея упрощения - увеличение матрицы графа для упрощения написания кода, при нахождении объекта около границы нам не требуется делать дополнительное проверки выхода за границы матрицы, потому что мы попадаем на рамку

В случае задачи с конем необходимо увеличить размер матрицы с каждой стороны на 2, чтобы не делать проверку выхода за границы.

Реализация:
```
int main() {
	int n;
	cin >> n;
	int xstart, ystart, xfinish, yfinish;
	cin >> xstart >> ystart >> xfinish >> yfinish;
	xstart++;
	ystart++;
	xfinish++;
	yfinish++;
	vector<vector<int>> DP(n + 4, vector<int>(n + 4, 100000));
	for (int i = 2; i < n + 2; i++)
		for (int j = 2; j < n + 2; j++)
			DP[i][j] = -1;
	DP[xstart][ystart] = 0;
}
```
далее запускаем обычный бфс

## Список соседей 
Идея упрощения кода:
Выгодно сделать список соседей т.к. мы жестко фиксируем ребра и знаем точно, как он будем ходить.
```
int main() {
	vector<pair<int, int>> Step;
	Step.push_back(make_pair(1, 2));
	Step.push_back(make_pair(1, -2));
	Step.push_back(make_pair(-1, 2));
	Step.push_back(make_pair(-1, -2));
	Step.push_back(make_pair(2, 1));
	Step.push_back(make_pair(2, -1));
	Step.push_back(make_pair(-2, 1));
	Step.push_back(make_pair(2, 1));
	Step.push_back(make_pair(-2, -1));
}

```
Функция для обхода соседей 
кусок main
```
queue<pair<int, int>> q;
pair<int, int> tmp;
tmp.first = xstart;
tmp.second = ystart;
while (q.size() > 0) {
	tmp = q.front();
	q.pop();
	Hod(DP, Step, q, tmp);
}
cout << DP[xfinish][yfinish];
```

Запускаем бфс
```
void Hod(vector<vector<int>>& DP,
	vector<pair<int, int>>& Step,
	queue<pair<int, int>>& Q,
	pair<int, int> pos)
{
	pair<int, int> buf;
	for (int i = 0; i < Step.size(); i++) {
		buf.first = pos.first + Step[i].first;
		buf.second = pos.second + Step[i].second;
		if (DP[buf.first][buf.second] == -1) {
			DP[buf.first][buf.second] = DP[pos.first][pos.second] + 1;
			Q.push(buf);
		}
	}
}
```

В итоге получаем код
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <queue>

using namespace std;

void Hod(vector<vector<int>>& DP,
	vector<pair<int, int>>& Step,
	queue<pair<int, int>>& Q,
	pair<int, int> pos)
{
	pair<int, int> buf;
	for (int i = 0; i < Step.size(); i++) {
		buf.first = pos.first + Step[i].first;
		buf.second = pos.second + Step[i].second;
		if (DP[buf.first][buf.second] == -1) {
			DP[buf.first][buf.second] = DP[pos.first][pos.second] + 1;
			Q.push(buf);
		}
	}
}

int main() {
	int n;
	cin >> n;
	int xstart, ystart, xfinish, yfinish;
	cin >> xstart >> ystart >> xfinish >> yfinish;
	xstart++;
	ystart++;
	xfinish++;
	yfinish++;
	vector<vector<int>> DP(n + 4, vector<int>(n + 4, 100000));
	for (int i = 2; i < n + 2; i++)
		for (int j = 2; j < n + 2; j++)
			DP[i][j] = -1;
	DP[xstart][ystart] = 0;

	vector<pair<int, int>> Step;
	Step.push_back(make_pair(1, 2));
	Step.push_back(make_pair(1, -2));
	Step.push_back(make_pair(-1, 2));
	Step.push_back(make_pair(-1, -2));
	Step.push_back(make_pair(2, 1));
	Step.push_back(make_pair(2, -1));
	Step.push_back(make_pair(-2, 1));
	Step.push_back(make_pair(2, 1));
	Step.push_back(make_pair(-2, -1));

	queue<pair<int, int>> q;
	pair<int, int> tmp;
	tmp.first = xstart;
	tmp.second = ystart;
	while (q.size() > 0) {
		tmp = q.front();
		q.pop();
		Hod(DP, Step, q, tmp);
	}
	cout << DP[xfinish][yfinish];
}
```

Странные гриды(как на DEVELOBEAR)
![[Pasted image 20250405174728.png]]
Как оформить правила переходов?
- Пытаемся перевести в нормальную матрицу
Но это не поможет ;(
Самое сложное в гидрах - перевести гидру в нормальную матрицу (Исправление: Придумать правило обхода матрицы, не надо её перестраивать!)
