Система непересекающихся множеств.
Можно отнести как и к [[Графы||Графам]], так и к [[Математика||Теории множеств]].
В целом всё СНМ требуется для одного алгоритма Крускала.
СНМ - структура данных, которая хранит в себе непересекающиеся множества на n элементах,
а также выполняют два запроса:
```cpp
get(a) // вернуть индитификатор множества, в котором лежит элемент a
union(a, b) // объеденить два множества, в одном из которых лежит a, а в другом b
```
Основное применение алгоритма СНМ это построение минимальных остовных деревьев (алгоритм Крускала)
Остовное дерево - это подграф связного графа, который содержит все его вершины и также представляет собой дерево.
Минимальное остовное дерево - это подграф связного графа, который содержит все его вершины и также представляет собой дерево, чья сумма весов ребер минимально возможная

Подставим перед собой задачу:
Пусть у нас есть `n` элементов (вершин), каждый из которых состоит в собственном множестве. Мы хотим делать две операции над нашими элементами:
1) Проверить, что два элемента располагаются в одном множестве 
2) Соединить две вершины ребром и тем самым объединить два множества в одно
#### Наивная реализация
Создадим вектор `Color`, где `Color[i]` определяет в каком множестве располагается элемент `i`. Изначально все элементы помечены своим числом\цветом `Color[i] = i`.
```cpp
int n;
cin >> n;
vector<int> Color(n + 1);
for (int i = 1; i <= n; ++i)
	Color[i] = i;
```
Обработка событий
```cpp
int q, type, a, b;
cin >> q;
while (q--)
{
	cin >> type >> a >> b;
	if (type == 1)
		if (Color[a] == Color[b])
			cout << "YES\n";
		else
			cout << "NO\n";
	else
	{
		int tmp = Color[a];
		for (int i = 1; i <= n; ++i)
			if (tmp == Color[i])
				Color[i] = Color[b];
	}
}
```
Проверка элементов в одном множестве по трудоемкости `O(1)`
Объединение множеств по трудоемкости `O(n)`

Итоговая трудоемкость всей программы `O(qn)`. Это TL в большинстве задач.

Придумаем оптимизацию хранения элементов внутри одного множества.
Введем дополнительные параметры для каждого элемента:
1. Количество подчиненных у элемента
2. Номер элемента непосредственного начальника.
Самый главный начальник (корень или мама) в множестве ссылается сам на себя и все элементы множества ему подчиняются

Изменит смысл операций:
1. Вместо проверки двух элементов в одном множестве, будем проверять, что главные элементы множеств совпадают
2. Вместо соединения двух элементов `a` и `b` ребром, будем соединять корни множеств
Если упрощать смысл, то все действия проходят через главные элементы множеств. Трудоемкость алгоритма $O(n * log_2(n)$

Для оптимизации нам требуются 
```cpp
vector<int> Count_elem(n + 1), Putty(n + 1);
```
`Count_elem[i]` хранит количество подчиненных у элемента `i`, а `Putty[i]` хранит непосредственного начальника для `i` элемента.
```cpp
int n;
cin >> n;
vector<int> Count_elem(n + 1), Putty(n + 1);
for (int i = 1; i <= n; ++i)
{
	Count_elem[i] = 1;
	Putty[i] = i;
}
```
Важной оптимизацией алгоритма является правило объединения множеств. Нам необходимо к большему множеству добавлять меньшее! Обратная операция будет неэффективной
```cpp
int q, type, a, b;
cin >> q;
while (q--)
{
	cin >> type;
	while (a != Putty[a])
		a = Putty[a];
	while (b != Putty[b])
		b = Putty[b];
	
	if (type == 1)
		if (a == b)
			cout << "YES\n";
		else
			cout << "NO\n";
	else
		if (a != b)
			if (Count_elem[a] > Count_elem[b])
			{
				Count_elem[a] += Count_elem[b];
				Putty[b] = a;
			}
			else
			{
				Count_elem[b] += Count_elem[a];
				Putty[a] = b;
			}	
}
```
Задача:
Пусть дан взвешенный неориентированный граф из n вершин и m ребер.
Каждое ребро задается 3 числами $u_i, v_i, w_i$ - номера вершин и вес.
Необходимо оставить такие ребра что выполняется два условия:
1) Граф остается связным
2) Сумма ребер минимально возможная
![[Pasted image 20251101211624.png]]
Дан граф(см.фото a)

![[Pasted image 20251101211648.png]]
![[Pasted image 20251101211659.png]]
![[Pasted image 20251101211709.png]]
![[Pasted image 20251101211717.png]]
![[Pasted image 20251101211737.png]]
![[Pasted image 20251101211747.png]]
![[Pasted image 20251101211757.png]]
берем минимальный по весу граф и соединяем вершины если они из разных множеств.
#### Пример для задачи на минимальное остовное дерево
Есть карта с городами и дорогами между ними, каждая дорога имеет определённую длину. Задача — соединить все города дорогами так, чтобы можно было добраться из любого города в любой другой (возможно, через другие города), а общая длина использованных дорог была минимальной.
