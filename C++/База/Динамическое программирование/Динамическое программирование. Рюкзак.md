

---

# [[Динамическое программирование||Динамического программирования]]

## Постановка задачи

Есть $n$ предметов, каждый из которых имеет собственную ценность $c_i$ и собственный вес $w_i$. Рюкзак способен вместить вес равный $s$.

**Вопрос**  
Какие предметы следует брать, чтобы получить максимальную ценность?

![[Pasted image 20250322171707.png]]

---

## Доп. условие 1: Мы можем делить предметы на части (дробный рюкзак)

### Решение (жадный алгоритм)

1) Собрать `vector<pair<double, pair<int, int>>>`, где:
   - `first` — цена за кг ($c_i / w_i$),
   - `second` — пара (вес, ценность)
2) Отсортировать вектор по убыванию цены за кг
3) Брать в первую очередь самые дорогие за кг
4) Если предмет не помещается целиком — берем кусок, который помещается

### Реализация (с твоим стилем)

```cpp
vector<pair<double, pair<int, int>>> items;
for (int i = 1; i <= n; i++) {
    double ratio = (double)C[i] / W[i];
    items.push_back({ratio, {W[i], C[i]}});
}
sort(items.begin(), items.end(), greater<pair<double, pair<int, int>>>());

double total_value = 0;
int remaining = s;

for (auto &item : items) {
    int w = item.second.first;
    int c = item.second.second;
    if (remaining == 0) break;
    if (w <= remaining) {
        total_value += c;
        remaining -= w;
    } else {
        double part = (double)remaining / w;
        total_value += c * part;
        remaining = 0;
    }
}
cout << total_value << endl;
```

---

## Доп. условие 2: Только целые предметы (0-1 рюкзак)

### "Грубая" реализация для маленького $n$ — полный перебор

```cpp
vector<int> Mask(n + 1);
int best = 0;
for (int i = 0; i < (1 << n); i++) {
    int tmp = i, sum_c = 0, sum_w = 0;
    for (int j = 1; j <= n; j++) {
        Mask[j] = tmp % 2;
        tmp /= 2;
    }
    for (int j = 1; j <= n; j++) {
        if (Mask[j] == 1) {
            sum_c += C[j];
            sum_w += W[j];
        }
    }
    if (sum_w <= s) {
        if (sum_c > best)
            best = sum_c;
    }
}
```

> ❌ Работает только при $n \leq 20$

---

## Основное решение: Динамическое программирование

![[Pasted image 20250322172654.png]]

### Вопросы

### 1. Что храним?

Создаём двумерный массив `DP`.  
В ячейке `DP[i][j]` будем хранить:
- `-1`, если **невозможно** собрать вес $ j $ из первых $ i $ предметов,
- иначе — **максимальную ценность**, которую можно получить.

---

### 2. Как считаем ячейку?

- Если $w_i > j$:  
  `DP[i][j] = DP[i-1][j]`
- Если $w_i \leq j$:  
  `DP[i][j] = max(DP[i-1][j], DP[i-1][j - w[i]] + c[i])`

---

### 3. Что является простейшим случаем?

При $i = 0$ (нет предметов):
- Вес 0 — ценность 0,
- Вес $> 0$ — недостижим.

```cpp
DP[0][0] = 0;
for (int j = 1; j <= s; j++) DP[0][j] = -1;
```

---

### 4. Как обходить ДП?

Классический обход:  
**Слева направо, сверху вниз**, начиная с $i = 1$

---

### 5. Где хранится ответ?

В последней строке (`DP[n][j]`), нужно найти **максимальное значение** среди всех $j \leq s$.

---

### Пример

**Веса:** 4, 8, 4, 12, 7  
**Цены:** 4, 10, 5, 18, 20  
**Вместимость:** 13

|        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |
|--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| 0 пр.  | 0 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |
| 1 пр.  | 0 |-1 |-1 |-1 | 4 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |
| 2 пр.  | 0 |-1 |-1 |-1 | 4 |-1 |-1 |-1 |10 |-1 |-1 |-1 |14 |-1 |
| 3 пр.  | 0 |-1 |-1 |-1 | 5 |-1 |-1 |-1 |10 |-1 |-1 |-1 |15 |-1 |
| 4 пр.  | 0 |-1 |-1 |-1 | 5 |-1 |-1 |-1 |10 |-1 |-1 |-1 |18 |-1 |
| 5 пр.  | 0 |-1 |-1 |-1 | 5 |-1 |-1 |20 |10 |-1 |-1 |25 |18 |25? |


---

### Реализация

```cpp
vector<vector<int>> DP(n + 1, vector<int>(s + 1, -1));
DP[0][0] = 0;

for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= s; j++) {
        DP[i][j] = DP[i - 1][j];
    }
    for (int j = 0; j <= s; j++) {
        if (j >= W[i] && DP[i - 1][j - W[i]] != -1) {
            DP[i][j] = max(DP[i][j], DP[i - 1][j - W[i]] + C[i]);
        }
    }
}

int ans = 0;
for (int j = 0; j <= s; j++) {
    if (DP[n][j] > ans)
        ans = DP[n][j];
}
cout << ans;
```

---

## Восстановление маршрута

Грубо говоря, просто идём **вверх-влево** по таблице.

```cpp
int ans = 0, pos = 0;
vector<int> Res;

for (int j = 0; j <= s; j++) {
    if (DP[n][j] > ans) {
        ans = DP[n][j];
        pos = j;
    }
}

for (int i = n; i > 0; i--) {
    if (DP[i][pos] != DP[i - 1][pos]) {
        Res.push_back(i);
        pos = pos - W[i];
    }
}

for (int i = Res.size() - 1; i >= 0; i--) {
    cout << Res[i] << ' ';
}
```

---

## Усложнения рюкзака

- Предметы могут весить **0 кг** → нужно обрабатывать отдельно (если $c_i > 0$, можно брать всегда)
- Кол-во способов больше → может появляться несколько путей в ДП
- У предмета больше вариантов выбора (например, **можно брать не 0 или 1, а до $k_i$ штук**) → **ограниченный рюкзак**
- **Неограниченный рюкзак** — можно брать сколько угодно каждого предмета
