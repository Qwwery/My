Еще один важный раздел [[Математика||Математики]]
В спор-проге задачи на комбинаторику обычно разделяют на два типа:
1. Посчитать сложный объект и в качестве результата вывести некоторое число
2. Сгенерировать комбинаторный ответ / или вывести все подходящие комбинаторные объекты
Основные комбинаторные объекты
1. Перестановка 
2. Размещение
3. Сочетание
4. Перестановка с повторением
5. Размещение с повторением
6. Сочетание с повторением

# Перестановка
Перестановка n объектов\элементов - это способ расположения с учетом порядка. Например avc, bca, cab - это разные перестановки букв a, b и c.

Кол-во таких перестановок обозначают, как 
$$
P_n = n!
$$

## Реализация перестановки
```
long long res = 1;
int n;
cin >> n;
for (int i = 1; i <= n; i++) {
	 res += i;
}
cout << res << '\n';
```
Или
```
long long P(int n) {
	if (n > 0) {
		return n * P(n - 1);
	}
	else {
		return 1;
	}
}
```

## Размещение
Размещение из n по k - это упорядоченный набор из k различных элементов, взятых из некоторого множества с мощностью n, где k <= n. То есть некая перестановка k выбранных элементов из n.
**A из n по k = n! / (n - k)!**
$$
A_n^k = \frac{n!}{(n - k)!}
$$




## Сочетание
Сочетание из n по k - это неупорядоченный набор из k различных элементов, взятых из некоторого множества с мощностью n, где k <= n. То есть набор, для которого порядок выбора не имеет значения.
$$
C^k_n = \frac{A^k_n}{k!} = \frac{n!}{(n - k)!k!}
$$
С из n по 0 = 1
C из n по 1 = n

Реализации:
(плохая)
```
long lnog res = 1;
int n, k;
cin >> n >> k;
for (int i = 1; i <= n; i++) {
	 res *= i;
}
for (int i = 1; i <= k; i++) {
	res /= i;
}
for (int i = 1; i <= n - k; i++) {
	res /= i;
}
cout << res;
```
(более хорошая)
```
long long res = 1;
int n, k;
cin >> n >> k;
for (int i = max(k, n - k) + 1; i <= n; i++) {
	res *= i;
}
for (int i = 1; i <= max(k, n - k); i++) {
	res /= i;
}
cout << res;
```
(еще лучше)
Если в задаче гарантированно, что число помещается в int или long long, то можно разбить формулу на произведение.
![[Pasted image 20250301173651.png]]
```
vector <int> Level(n + 1);
for (int i = max(k, n - k) + 1; i <= n; i++) {
	int tmp = i;
	for (int j = 2; j * j <= tmp; j++) {
		while (tmp % j == 0) {
			tmp /= j;
			Level[j]++;
		}
	}
	if (tmp != 1) {
		Level[tmp]++;
	}
}
for (int i = 1; i <= min(k, n - k); i++) {
	int tmp = i;
	for (int j = 2; j * j <= tmp; j++) {
		while (tmp % j == 0) {
			tmp /= j;
			Level[j]--;
		}
	}
	if (tmp != 1) {
		Level[tmp]++;
	}
}
for (int i = 1; i <= n; i++) {
	while (Level[i] > 0) {
		res *= i;
		Level[t]--
	}
}
```
где-то опечатки, что-то я не совсем понял, где
-
![[Pasted image 20250301174416.png]]
![[Pasted image 20250301174526.png]]
Программный способ нахождения чисел сочетания через треугольник Паскаля (хороший вариант)
![[Pasted image 20250301174735.png]]

```
vector<vector<long long>> DP(n + 1, vector<long long>(n + 1));
```
# Перестановка с повторениями
$$
P_n(n_1,n_2,n_3,...,n_h) = n! / n_1! * n_2! * n_3! * ... * n_2!
$$
# Размещение с повторениями
$$
A^k_n = n ^ k
$$
# Сочетание с повторениями
$$
C^k_n = C^k_(n+k-1) = \frac{(n + k - 1)!}{k!(n - 1)!}
$$

