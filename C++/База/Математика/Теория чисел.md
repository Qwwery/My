Одна из главных частей в спорт-проге из раздела [[Математика||Математики]].
Простые числа - натуральное число, у которого только 2 делителя (1 и само число) 1 - не простое.
Примеры: 2, 3, 7, 11...

Составное число - натуральное число, у которого больше, чем 2, делителя
Например: 4, 6, 10...

Единица - ни простое, ни составное число
## Проверка на простоту числа
Поставим задачу, проверить число на простоту. Является ли число n простым. Проверим линейным алгоритмом O(n)
```
int n;
cin >> n;
int count = 0;
for (int i = 1; i <= n; i++)
	if (n % i == 0)
		count++;
if (count == n)
	cout << "YES";
else 
	cout << "NO";
```
Оптимизируем алгоритм. Заметим, что если число является составным, то его можно представить в виде произведения n = a * b, где будет выполняться неравенства a <= sqrt(n) и
sqrt(n) <= b. Воспользуемся этим свойством и будем проверять до корня числа
```
int n;
cin >> n;
int count = 0;
for (int i = 2; i <= sqrt(n); i++)
	if (n % i == 0)
		count++;
if (count == 0)
	cout << "YES";
else 
	cout << "NO";
```
sqrt() очень плохая операция, т.к. она хранит в памяти плохую часть числа, компьютер её округляет, и получается немного другое число (sqrt(25) = 4.9999999997)
## Вывод всех делителей числа

Задача вывеси все делители числа
Наивное решение:
```
int n;
cin >> n;
for (int i = 1; i <= n; i++)
	if (n % i == 0)
		cout << i << ' ';
```
Асимптотика O(n)

Улучшение также через корень
```
int n;
cin >> n;
vector<int> A;
for (long long i = 1; i*i <= n; i++)
	if (n % i == 0) {
		A.push_back(i);
		if (i * i != n)
			A.push_back(n / i);
	}
sort(A.begin(), A.end());
for (int i = 0; i < A.size(); i++)
	cout << A[i] << ' ';
```
Асимптотика в таком случае считается O(sqrt(n)). Метод sort() не сильно нагружает код(т.к. у числа всегда мало делителей, и сортировка малого массива очень мало)
## Вывод всех простых делителей числа
Поставим пред собой более сложную задачу. Разложить число n на простые множители
```
int n;
cin >> n;
for (long long i = 2; i * i <= n; i++)
	while (n % i == 0) {
		cout << i << ' ';
		n /= i;
	}
if (n != 1) {
	cout << n;
}
```
## Решето Эратосфена
Самый популярный алгоритм 
Алгоритм находит все целые простые числа от 1 до n (да, да, для той самой задачи)
```
int n;
cin >> n;
vector<int> A(n + 1);
A[0] = 1;
A[1] = 1;
for (int i = 2; i <= n; i++)
	if (A[i] == 0)
		for (int j = 2 * i; j <= n; j += i)
			A[j] = 1;
```
Это наивный вариант решения 
Есть оптимизация
Приведем немного улучшенную версию реализации алгоритма Решето. Эратосфена.
Трудоёмкость алгоритма O(n * log2(n))
1) Начинаем не с 2 * j, а с i * i
2) Замещаем int на long long
```
int n;
cin >> n;
vector<int> A(n + 1);
vector<int> B;
A[0] = 1;
A[1] = 1;
for (long long i = 2; i <= n; i++) 
	if (A[i] == 0) {
		B.push_back(i);
		for (long long j = i * i; j <= n; j += i)
			A[j] = 1;
	}
```
## Взятие ответа по остатку
Рассмотрим задачу, где нам необходимо найти произведение целых чисел и выдать результат по остатку от числа mod.

Наивное решение - найти произведение чисел, а потом взять по остатку:
$$
(a_1 * a_2 * a_3 * a_4 * .. * a_n)\%mod
$$
К сожалению при перемножении чисел мы можем выйти за пределы типов данных.

Заметим, что любое целое число можно представить в виде n = k * mod + h, 
где 0 <= h <= mod

Для того, чтобы не выходить за типы данных при перемножении, мы можем брать остаток после каждого умножения 
$$
(...(((a_1 \% mod) * a_2 \% mod) * a_3 \% mod) ... a_n) \% mod
$$
я думаю, стоит оставить тут решение задачи пары чисел
M. Пары чисел
ограничение по времени на тест
1 second
ограничение по памяти на тест
256 megabytes

Допустим, мы имеем пару чисел (_a_, _b_). Мы можем получить новую пару чисел вида (_a_ + _b_, _b_) или (_a_, _a_ + _b_) из данной. Назовем такое действие шагом.
Пусть начальная пара чисел — (1,1). Ваша задача — найти число _k_, наименьшее количество шагов, необходимых чтобы получить из (1,1) пару, в которой хотя бы одно число равно _n_.

Входные данные
Входные данные содержат единственное целое число _n_ (1 ≤ _n_ ≤ 106).

Выходные данные
Выведите единственное число _k_.
```
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
long long cnt;
long long gcd(long long a, long long b) {
	if (b == 0) {
		if (a != 1)
			cnt = 1000000000;
		cnt += a - 1;
		return a;
	}
	else {
		cnt += a / b;
		return gcd(b, a % b);
	}
			
}

int main() {
	long long n;
	cin >> n;
	long long min_count = 1000000000;
	for (long long i = 1; i < n; i++) {
		cnt = 0;
		gcd(n, i);
		min_count = min(min_count, cnt);
	}
	if (min_count == 1000000000)
		cout << 0;
	else
		cout << min_count - 1;
}
```
Здесь присутствует функция gcd, которая немного отличается от той, что прописана выше.