[[Структуры данных]] в языке C++

Ассоциативные контейнеры представляют такие контейнеры, где с каждым элементом ассоциирован некоторый ключ, и этот ключ применяется для доступа к элементу в контейнере

В C++ ассоциативные контейнеры представлены множествами (set) и картами\словарями (map). Также существует и multi-версии этих контейнеров, в которых допускается повторы ключей. Эти структуры данных основаны на сбалансированных деревьях поиска.

set автоматически сортирует элементы добавляемые в массив. По другому set называют множеством. При добавлении в set повторяющегося элемента будет хранится только один его экземпляр.

Свойства set:
1. Все элементы уникальны. Нет повторяющихся
2. Все элементы упорядочены по возрастанию

```
set<int> st;
st.insert(10);
int tmp = *st.begin();
```

## Методы:

^788aeb

```
.empty()        - Проверяет, является ли set пустым
.size()         - Возращает количество элементов в set
.begin()        - Возращяет итератор на первый элемент 
.end()          - Возращает итератор за последний элемент
.rbegin()       - Возращает итератор перед первым элементом
.rend()         - Возращает итератор перед первым элементом 
.find(key)      - Возращает иторатор на элеиент равный key. Если нет, то .end()
.insert(a)      - Добавляет элемент a в set
.erase(a)       - Удаляет элемент из set по значению равному a.(не проверяет)
.erase(iter)    - Удаляет элемент по итератору из set
.lower_bound(a) - Возращает итератор на первый элемент больший или равный a
.upper_bound(a) - Возращает итератор на первый элемент больший a
```

^89e701

## Пример решения задачи на бин. поиск
.lower_boud и .upper_bound могут заменить Бинарный поиск по массиву
Задача экзамен по истории
```
int n, q, tmp, count = 0;
set<int> st;
cin >> n;
for (int i = 0; i < n; i++) {
	cin >> tmp;
	st.insert(tmp);
}
cin >> q;
for (int i = 0; i < q; i++) {
	cin >> tmp;
	if (st.find(tmp) != st.end())
		count++;
}
cout << count;
```
