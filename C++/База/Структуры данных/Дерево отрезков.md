Эта тема является комбинацией из 4 других [[Динамическое программирование]], [[Структуры данных]], [[Два указателя]] и 
## Задача
поставим перед собой задачу 

Дан целочисленный массив A длинны n. Необходимо найти сумму элементов массива с позиции l до позиции r.
a1, a2, a3, ..., an-1, an

Можно решить через [[Префикс-сумма||Префикс суммы]]

Усложнение задачи в виде добавления двух типов операций
1) Мы задаем вопрос найти сумму элементов с позиции l до r
2) Мы хоти изменить один элемент под номером id на другую позицию
В таком случае обработка запросов при помощи алгоритма префикс суммы не выгодна, ведь при изменении одного элемента в массиве меняется огромное количество элементов в массиве префикс функции 

Варианты:
1) SQRT декомпозиция
2) Дерево Фенвика
3) Дерево отрезков

## Дерево отрезков
Дерево отрезков - это структура данных, которая позволяет эффективно(т.е. за log2(n)) реализовать операции следующего вида: нахождение суммы/минимума элементов массива в заданном отрезке (a[l...r], где l и r поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом под-отрезке массива.
![[Pasted image 20250419172251.png]]
ВНИМАНИЕ!!! ПОСЛЕ ЭТОГО АЛГОСА ПОЯВЛЯЕТСЯ БОЛЕЗНЬ ВЕЗДЕ И ВСЮДУ, КОГДА ПИХАЮТ АЛГОС ТУДА, КУДА НЕ НАДО!!!
Реализация дерева отрезков:
1) На массиве
2) На матрице
3) Через собственную структуру на узлах
4) Реализации без лишнего выделения памяти
![[Pasted image 20250419172504.png]]

Реализуем вариант дерева отрезков на массиве со спец. свойствами.
1) Наш исходный массив мы хотим хранить нумерацию элементов с 0 до n - 1.
2) Весь начальный массив мы хотим хранить в листьях. Для удобства реализации мы хотим, чтобы количество листьев равнялось 2^z и выполнялось условие n <= 2^z.
3) Нейтральный элемент для сложения 0. Ячейки, которые будут создаваться лишними, будут хранить в себе значение нейтрального элемента. Для операции умножения нейтральный элемент может быть 1, для НОД пометка со значением -1.
4) Корень нашего дерева будет иметь номер в массиве равным 1.
5) Для каждой вершины строго определяем нумерацию их сыновей. Если номер вершины равняется i, то номер левого сына 2 * i и правого сына 2 * i + 1.

## Пример
Массив A имеет длину 6 и хранит в себе набор элементов {4, 1, 4, 2, 5, 3}
![[Pasted image 20250419173438.png]]
Нумерация элементов:
![[Pasted image 20250419173547.png]]
Ряд красивых вещей:
1) Нумерация элементов левой ветки дерева 2^i.
2) Номер первого листа равняется 8 или 2^z.
3) Количество листьев равняется 8 или 2^z.

Разделим реализацию дерева отрезков на 4 части:
1) Инициализация дерева
2) Update 1 элемента в дереве
3) Поиск ответа
4) Обработка запросов задачи

Для инициализации дерева необходимо определить количество элементов в нем, количество листьев первого листа. Обычно для определения количества элементов всегда берут величину с запасом 4 * n или 8 * n
```cpp
int n;
cin >> n;
vector<long long> Tree_sum(n * 4);
int number_left_list = 1;
int count_list = 1;
while (count_list < n) {
	count_list *= 2;
	number_left_list *= 2;
}
int q;
char type;
int l, r, id, c;
```
## Операция update
Для обновления одного элемента необходимо определить номер листа, которому соответствует номер из запроса. Далее обновить все элементы в дереве, которые зависят от листа. (пробег от листа к корню)
![[Pasted image 20250419174641.png]]
Для обновления одного элемента необходимо определить номер листа, которому соответствует номер из запроса. Далее обновить все элементы в дереве, которые зависят от листа. (пробег от листа к корню)
```cpp
void update_tree_sum(vector<long long>& Tree_sum,
	int number_list,
	long long data)
{
	Tree_sum[number_list] = data;
	while (number_list > 1) {
		number_list /= 2;
		Tree_sum[number_list] = Tree_sum[number_list * 2] + Tree_sum[number_list * 2 + 1];
	}
}
```
## Поиск ответа на отрезке
Пусть у нас есть запрос поиск суммы с 1 по 5 элемент a1 + a2 + a4 + a4 + a5

При использования ДО у нас есть несколько вариантов сбора ответа:
1) Пробежаться по листьям T8 + T9 + T10 + T11 + T12
2) Собрать часть ответа через "Большие ячейки" T4 + T5 + T12
3) Использовать хранение ДО по максимуму T2 + T12


![[Pasted image 20250419175526.png]]
Будем бежать от корня к листьям и смотреть на ячейку является ли она частью ответа, не является частью ответа или частично является ответом.
Реализация:
```cpp
long long Sum(vector<long long> Tree_sum, // Вектор нашего дерева
	int id, // Номер, в котором мы находимсся изначально (начальное знч. = 1)
	int l, // Диапазон для которого хранится ответ l включительно
	int r, // r не включительно
	int find_l, // Границы, на которых я хочу найти ответ
	int find_r
){
	if (find_l <= l && r <= find_r)
		return Tree_sum[id];
	if (r <= find_l || find_r <= l) // Случай, когда яч. не является частью ответа
		return 0;
	int mid = (l + r) / 2; // Делим частицы пополам
	long long sum1 = Sum(Tree_sum, id * 2, l, mid, find_l, find_r); // Переходим в левого сына
	
	long long sum2 = Sum(Tree_sum, id * 2 + 1, mid, r, find_l, find_r); // Перехожим п правого сына
	return sum1 + sum2;
}
```

## Обработка запросов
Реализация:
```
cin >> q;
for (int i = 0; i < q; i++) {
	cin >> type;
	if (type == '?') {
		cin >> l >> r;
		l--;
		cout << Sum(Tree_sum, 1, 0, count_list, l, r) << '\n';
	}
	else {
		cin >> if >> c;
		id--;
		update_tree_sum(Tree_sum, number_left_list + id, c);
	}
}
```

## Усложнение
1) Другие операции
2) Более сложные пробеги по дереву отрезков. Например, со специальной проверкой сыновей или только одного из них
3) Массовые операции, так называемое проталкивание 
4) Многомерные деревья
