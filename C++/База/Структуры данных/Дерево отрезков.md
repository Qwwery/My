Эта тема является комбинацией из 4 других [[Динамическое программирование]], [[Структуры данных]], [[Два указателя]] и 
## Задача
поставим перед собой задачу 

Дан целочисленный массив A длинны n. Необходимо найти сумму элементов массива с позиции l до позиции r.
a1, a2, a3, ..., an-1, an

Можно решить через [[Префикс-сумма||Префикс суммы]]

Усложнение задачи в виде добавления двух типов операций
1) Мы задаем вопрос найти сумму элементов с позиции l до r
2) Мы хоти изменить один элемент под номером id на другую позицию
В таком случае обработка запросов при помощи алгоритма префикс суммы не выгодна, ведь при изменении одного элемента в массиве меняется огромное количество элементов в массиве префикс функции 

Варианты:
1) SQRT декомпозиция
2) Дерево Фенвика
3) Дерево отрезков

## Дерево отрезков
Дерево отрезков - это структура данных, которая позволяет эффективно(т.е. за log2(n)) реализовать операции следующего вида: нахождение суммы/минимума элементов массива в заданном отрезке (a[l...r], где l и r поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом под-отрезке массива.
![[Pasted image 20250419172251.png]]
ВНИМАНИЕ!!! ПОСЛЕ ЭТОГО АЛГОСА ПОЯВЛЯЕТСЯ БОЛЕЗНЬ ВЕЗДЕ И ВСЮДУ, КОГДА ПИХАЮТ АЛГОС ТУДА, КУДА НЕ НАДО!!!
Реализация дерева отрезков:
1) На массиве
2) На матрице
3) Через собственную структуру на узлах
4) Реализации без лишнего выделения памяти
![[Pasted image 20250419172504.png]]

Реализуем вариант дерева отрезков на массиве со спец. свойствами.
1) Наш исходный массив мы хотим хранить нумерацию элементов с 0 до n - 1.
2) Весь начальный массив мы хотим хранить в листьях. Для удобства реализации мы хотим, чтобы количество листьев равнялось 2^z и выполнялось условие n <= 2^z.
3) Нейтральный элемент для сложения 0. Ячейки, которые будут создаваться лишними, будут хранить в себе значение нейтрального элемента. Для операции умножения нейтральный элемент может быть 1, для НОД пометка со значением -1.
4) Корень нашего дерева будет иметь номер в массиве равным 1.
5) Для каждой вершины строго определяем нумерацию их сыновей. Если номер вершины равняется i, то номер левого сына 2 * i и правого сына 2 * i + 1.

## Пример
Массив A имеет длину 6 и хранит в себе набор элементов {4, 1, 4, 2, 5, 3}
![[Pasted image 20250419173438.png]]
Нумерация элементов:
![[Pasted image 20250419173547.png]]
Ряд красивых вещей:
1) Нумерация элементов левой ветки дерева 2^i.
2) Номер первого листа равняется 8 или 2^z.
3) Количество листьев равняется 8 или 2^z.

Разделим реализацию дерева отрезков на 4 части:
1) Инициализация дерева
2) Update 1 элемента в дереве
3) Поиск ответа
4) Обработка запросов задачи

Для инициализации дерева необходимо определить количество элементов в нем, количество листьев первого листа. Обычно для определения количества элементов всегда берут величину с запасом 4 * n или 8 * n
```cpp
int n;
cin >> n;
vector<long long> Tree_sum(n * 4);
int number_left_list = 1;
int count_list = 1;
while (count_list < n) {
	count_list *= 2;
	number_left_list *= 2;
}
int q;
char type;
int l, r, id, c;
```
## Операция update
Для обновления одного элемента необходимо определить номер листа, которому соответствует номер из запроса. Далее обновить все элементы в дереве, которые зависят от листа. (пробег от листа к корню)
![[Pasted image 20250419174641.png]]
Для обновления одного элемента необходимо определить номер листа, которому соответствует номер из запроса. Далее обновить все элементы в дереве, которые зависят от листа. (пробег от листа к корню)
```cpp
void update_tree_sum(vector<long long>& Tree_sum,
	int number_list,
	long long data)
{
	Tree_sum[number_list] = data;
	while (number_list > 1) {
		number_list /= 2;
		Tree_sum[number_list] = Tree_sum[number_list * 2] + Tree_sum[number_list * 2 + 1];
	}
}
```
## Поиск ответа на отрезке
Пусть у нас есть запрос поиск суммы с 1 по 5 элемент a1 + a2 + a4 + a4 + a5

При использования ДО у нас есть несколько вариантов сбора ответа:
1) Пробежаться по листьям T8 + T9 + T10 + T11 + T12
2) Собрать часть ответа через "Большие ячейки" T4 + T5 + T12
3) Использовать хранение ДО по максимуму T2 + T12


![[Pasted image 20250419175526.png]]
Будем бежать от корня к листьям и смотреть на ячейку является ли она частью ответа, не является частью ответа или частично является ответом.
Реализация:
```cpp
long long Sum(vector<long long> Tree_sum, // Вектор нашего дерева
	int id, // Номер, в котором мы находимсся изначально (начальное знч. = 1)
	int l, // Диапазон для которого хранится ответ l включительно
	int r, // r не включительно
	int find_l, // Границы, на которых я хочу найти ответ
	int find_r
){
	if (find_l <= l && r <= find_r)
		return Tree_sum[id];
	if (r <= find_l || find_r <= l) // Случай, когда яч. не является частью ответа
		return 0;
	int mid = (l + r) / 2; // Делим частицы пополам
	long long sum1 = Sum(Tree_sum, id * 2, l, mid, find_l, find_r); // Переходим в левого сына
	
	long long sum2 = Sum(Tree_sum, id * 2 + 1, mid, r, find_l, find_r); // Перехожим п правого сына
	return sum1 + sum2;
}
```

## Обработка запросов
Реализация:
```cpp
cin >> q;
for (int i = 0; i < q; i++) {
	cin >> type;
	if (type == '?') {
		cin >> l >> r;
		l--;
		cout << Sum(Tree_sum, 1, 0, count_list, l, r) << '\n';
	}
	else {
		cin >> if >> c;
		id--;
		update_tree_sum(Tree_sum, number_left_list + id, c);
	}
}
```

## Усложнение
1) Другие операции
2) Более сложные пробеги по дереву отрезков. Например, со специальной проверкой сыновей или только одного из них
3) Массовые операции, так называемое проталкивание 
4) Многомерные деревья

---
# EDU на codeforces
## Отрезок с максимальной суммой
Поставим перед собой задачу:
Дан некий массив из целых чисел размера n. Требуется найти подотрезок с максимальной суммой. Также дано число m и за ним m операций изменения массива вида i u, что означает присвоить элементу с индексом i значение u. Требуется находить подотрезок также после каждой операции изменения

Для того, чтобы решить эту задачу составим структуру для удобства
Будем хранить сумму элементов, максимальный префикс, максимальный суффикс, а также максимальный подотрезок в целом.
Для обновления элементов следует заметить, что 
![[Pasted image 20251031205225.png]]
```cpp
Tree[i].max_pref = max(Tree[2 * i].max_pref, Tree[2 * i].sum + Tree[2 * i + 1].max_pref);
```
На картинке:
красным обозначена сумма от `.sum` ветки `[2 * i]` и `.max_pref` ветки `[2 * i + 1]`
зеленым `.max_pref` ветки `[2 * i]`

Аналогичным образом мы определяем максимальный suff для `i` элемента дерева
Максимальная подпоследовательность у `i` предка будет максимумом среди трех значений:
```cpp
Tree[i].max_sub = max({ Tree[2 * i].max_sub, Tree[2 * i + 1].max_sub, Tree[2 * i].max_suff + Tree[2 * i + 1].max_pref });
```
Максимальной подпоследовательности левой ветки, максимальной подпоследовательностью правой ветки, а также максимального суффикса левой ветки + максимального префикса правой ветки. Ведь у нас всего три варианта развития событий, а именно когда ответ лежит полностью в правой ветке, когда ответ лежит полностью в левой ветке, или же когда ответ лежит посередине между левой и правой ветки.
### Реализация
```cpp
struct T
{
    ll sum = 0;
    ll max_pref = 0;
    ll max_suff = 0;
    ll max_sub = 0;
};

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    ll cnt = 1;
    while (cnt < n)
        cnt *= 2;
    vector<T> Tree(cnt * 2 + 1);
    for (int i = cnt; i < cnt + n; ++i) {
        cin >> Tree[i].sum;
        Tree[i].max_pref = Tree[i].sum;
        Tree[i].max_suff = Tree[i].sum;
        Tree[i].max_sub = Tree[i].sum;
    }
    for (int i = cnt - 1; i >= 1; --i)
    {
        if (Tree[2 * i].max_pref == LLONG_MIN)
            Tree[i] = Tree[2 * i + 1];
        else if (Tree[2 * i + 1].max_pref == LLONG_MIN)
            Tree[i] = Tree[2 * i];
        else {
            Tree[i].sum = Tree[2 * i].sum + Tree[2 * i + 1].sum;
            Tree[i].max_pref = max(Tree[2 * i].max_pref, Tree[2 * i].sum + Tree[2 * i + 1].max_pref);
            Tree[i].max_suff = max(Tree[2 * i + 1].max_suff, Tree[2 * i + 1].sum + Tree[2 * i].max_suff);
            Tree[i].max_sub = max({ Tree[2 * i].max_sub, Tree[2 * i + 1].max_sub, Tree[2 * i].max_suff + Tree[2 * i + 1].max_pref });
        }
    }
    cout << max(0LL, Tree[1].max_sub) << '\n';
    int ind;
    ll u;
    while (m--)
    {
        cin >> ind >> u;
        ind += cnt;
        Tree[ind].sum = u;
        Tree[ind].max_pref = u;
        Tree[ind].max_suff = u;
        Tree[ind].max_sub = u;
        for (ll i = ind / 2; i >= 1; i /= 2)
        {
            Tree[i].sum = Tree[2 * i].sum + Tree[2 * i + 1].sum;
            Tree[i].max_pref = max(Tree[2 * i].max_pref, Tree[2 * i].sum + Tree[2 * i + 1].max_pref);
            Tree[i].max_suff = max(Tree[2 * i + 1].max_suff, Tree[2 * i + 1].sum + Tree[2 * i].max_suff);
            Tree[i].max_sub = max({ Tree[2 * i].max_sub, Tree[2 * i + 1].max_sub, Tree[2 * i].max_suff + Tree[2 * i + 1].max_pref });
        }
        cout << max(0LL, Tree[1].max_sub) << '\n';
    }
    return 0;
}
```
---
## Первый элемент не меньше X
Поставим задачу:
Есть массив размера n, содержащий целые числа. Требуется отвечать на запросы: 
`1 i u`,
`2 x`
Тип запроса - первое число. Если тип запроса единица, тогда требуется заменить элемент индекса `i` на `u`, а иначе нужно найти индекс первого вхождения элемента в массив.

Для того чтобы решить эту задачу стоит додуматься до того, чтобы обходить дерево не от листьев к корню, а от корня к листьям. Мы соберем ДО на максимум и будем переходить в ту дочернюю ветку, в которой гарантированно есть число не меньше x и отдавать приоритет левому сыну.
![[Pasted image 20251031211644.png]]
Для примера возьмем массив `1 2 8 10 3 4 5 7`
Его ДО на максимум будет выглядеть так, как нарисовано на картинке.
Попробуем найти первый элемент больше 5, используя описанный выше алгоритм.
Пронумеруем дерево для удобства.
![[Pasted image 20251031211910.png]]
Из вершины 1 мы можем перейти в вершины 2 и 3, причем они обе больше 5, но т.к. нам надо найти первое вхождение, которое гарантированно будет левее, мы пойдем в левую вершину
![[Pasted image 20251031212031.png]]
Теперь мы в вершине 2. Из неё мы можем перейти в вершины 4 и 5. Но в вершине 4 значение меньше того, которое мы пытаемся найти, а потому нам приходиться перейти в вершину 5.
![[Pasted image 20251031212215.png]]
Теперь из вершины 5 мы можем перейти в лист 10 и 11. Т.к. оба подходят переходим в левый лист.
![[Pasted image 20251031212303.png]]
Таким образом за $O(log_n)$ Мы нашли первое вхождение числа не меньше x в массив.
Для обновления массива просто будем перезаписывать ДО на максимум.
### Реализация
```cpp
struct T
{
    ll max = 0;
};

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    ll cnt = 1;
    while (cnt < n)
        cnt *= 2;
    vector<T> Tree(cnt * 2 + 1);
    for (int i = cnt; i < cnt + n; ++i)
        cin >> Tree[i].max;
    for (int i = cnt - 1; i >= 1; --i)
        Tree[i].max = max(Tree[2 * i].max, Tree[2 * i + 1].max);
    int type;
    while (m--)
    {
        cin >> type;
        if (type == 1)
        {
            ll pos, u;
            cin >> pos >> u;
            pos += cnt;
            Tree[pos].max = u;
            for (ll i = pos / 2; i >= 1; i /= 2)
                Tree[i].max = max(Tree[2 * i].max, Tree[2 * i + 1].max);
        }
        else
        {
            ll k;
            cin >> k;
            ll pos = 1;
            while (pos < cnt)
                if (Tree[2 * pos].max >= k)
                    pos = 2 * pos;
                else
                    pos = 2 * pos + 1;
            
            cout << (Tree[pos].max >= k ? (pos - cnt) : -1) << '\n';
        }
    }
}
```
В данной реализации структура неуместна, но я оставил т.к. мне понравилось выносить в отдельную структуру элемент дерева.

---
## TODO
