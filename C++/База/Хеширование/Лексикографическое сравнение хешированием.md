### üîπ –ò–¥–µ—è
 
–ò—Å–ø–æ–ª—å–∑—É–µ–º **–ø–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã–µ —Ö–µ—à–∏ + –±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫**, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –¥–ª–∏–Ω—É –æ–±—â–µ–≥–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –¥–≤—É—Ö –ø–æ–¥—Å—Ç—Ä–æ–∫, –∑–∞—Ç–µ–º —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–µ—Ä–≤—ã–π –æ—Ç–ª–∏—á–∞—é—â–∏–π—Å—è —Å–∏–º–≤–æ–ª.

### üîπ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

 ```cpp
 #include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
const long long MOD1 = 1000000007;
const long long MOD2 = 1000000009;
const long long BASE = 131;

struct SimpleHashedString {
    string s;
    int n;
    vector<long long> pref1, pref2;  // –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã–µ —Ö–µ—à–∏
    vector<long long> pow1, pow2;    // —Å—Ç–µ–ø–µ–Ω–∏ –æ—Å–Ω–æ–≤–∞–Ω–∏—è

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
    SimpleHashedString(const string& str) : s(str), n(str.size()) {
        pref1.assign(n + 1, 0);
        pref2.assign(n + 1, 0);
        pow1.assign(n + 1, 1);
        pow2.assign(n + 1, 1);

        // –ü—Ä–µ–¥–ø–æ–¥—Å—á—ë—Ç —Å—Ç–µ–ø–µ–Ω–µ–π
        for (int i = 1; i <= n; ++i) {
            pow1[i] = (pow1[i-1] * BASE) % MOD1;
            pow2[i] = (pow2[i-1] * BASE) % MOD2;
        }

        // –ü—Ä–µ–¥–ø–æ–¥—Å—á—ë—Ç –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã—Ö —Ö–µ—à–µ–π
        for (int i = 0; i < n; ++i) {
            long long c = s[i] - 'a' + 1;  // 'a'=1, 'b'=2, ..., 'z'=26
            pref1[i+1] = (pref1[i] * BASE + c) % MOD1;
            pref2[i+1] = (pref2[i] * BASE + c) % MOD2;
        }
    }

    // –ü–æ–ª—É—á–∏—Ç—å —Ö–µ—à –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ [l, r] –∫–∞–∫ –ø–∞—Ä—É (h1, h2)
    pair<long long, long long> get_hash(int l, int r) {
        if (l > r) return {0, 0};
        long long h1 = (pref1[r+1] - (pref1[l] * pow1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        long long h2 = (pref2[r+1] - (pref2[l] * pow2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        return {h1, h2};
    }

    // –°—Ä–∞–≤–Ω–∏—Ç—å –¥–≤–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏: [l1, r1] vs [l2, r2]
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: -1 –µ—Å–ª–∏ –ø–µ—Ä–≤–∞—è < –≤—Ç–æ—Ä–∞—è, 0 –µ—Å–ª–∏ —Ä–∞–≤–Ω—ã, 1 –µ—Å–ª–∏ –ø–µ—Ä–≤–∞—è > –≤—Ç–æ—Ä–∞—è
    int compare(int l1, int r1, int l2, int r2) {
        int len1 = r1 - l1 + 1;
        int len2 = r2 - l2 + 1;
        int min_len = min(len1, len2);

        // –ë–∏–Ω–ø–æ–∏—Å–∫ –ø–æ –¥–ª–∏–Ω–µ –æ–±—â–µ–≥–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞
        int left = 0, right = min_len;
        int common = 0;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (mid == 0) {
                common = 0;
                left = mid + 1;
            } else {
                auto hash1 = get_hash(l1, l1 + mid - 1);
                auto hash2 = get_hash(l2, l2 + mid - 1);
                if (hash1 == hash2) {
                    common = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        // –ï—Å–ª–∏ –æ–±—â–∏–π –ø—Ä–µ—Ñ–∏–∫—Å –ø–æ–∫—Ä—ã–≤–∞–µ—Ç –æ–¥–Ω—É –∏–∑ —Å—Ç—Ä–æ–∫
        if (common == len1 && common == len2) return 0;  // —Ä–∞–≤–Ω—ã
        if (common == len1) return -1;  // –ø–µ—Ä–≤–∞—è –∫–æ—Ä–æ—á–µ ‚Üí –º–µ–Ω—å—à–µ
        if (common == len2) return 1;   // –≤—Ç–æ—Ä–∞—è –∫–æ—Ä–æ—á–µ ‚Üí –º–µ–Ω—å—à–µ

        // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–µ—Ä–≤—ã–π —Å–∏–º–≤–æ–ª –ø–æ—Å–ª–µ –æ–±—â–µ–≥–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞
        if (s[l1 + common] < s[l2 + common]) return -1;
        if (s[l1 + common] > s[l2 + common]) return 1;
        return 0;
    }
};
 ```
 
### üîπ –°–ª–æ–∂–Ω–æ—Å—Ç—å
 
 - O(n) –ü—Ä–µ–¥–ø–æ–¥—Å—á—ë—Ç
 - O(logn) –Ω–∞ –∑–∞–ø—Ä–æ—Å
 
 –û—Ç–ª–∏—á–Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –∑–∞–¥–∞—á, –≥–¥–µ –Ω—É–∂–Ω–æ —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å –º–Ω–æ–≥–æ –ø–æ–¥—Å—Ç—Ä–æ–∫ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ–¥—Å—Ç—Ä–æ–∫, –ø–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ —Å–¥–≤–∏–≥–∞).